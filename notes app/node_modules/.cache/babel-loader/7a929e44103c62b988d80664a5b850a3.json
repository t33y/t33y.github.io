{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @typedef {Array<Node> | string} ChildrenOrValue\n *   List to use as `children` or value to use as `value`.\n *\n * @typedef {Record<string, unknown>} Props\n *   Other fields to add to the node.\n */\n\n/**\n * Build a node.\n *\n * @param type\n *   Node type.\n * @param props\n *   Fields assigned to node.\n * @param value\n *   Children of node or value of `node` (cast to string).\n * @returns\n *   Built node.\n */\nexport var u =\n/**\n * @type {(\n *   (<T extends string>(type: T) => {type: T}) &\n *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\n *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\n *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\n *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\n *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\n * )}\n */\n\n/**\n * @param {string} type\n * @param {Props | ChildrenOrValue | null | undefined} [props]\n * @param {ChildrenOrValue | null | undefined} [value]\n * @returns {Node}\n */\nfunction u(type, props, value) {\n  /** @type {Node} */\n  var node = {\n    type: String(type)\n  };\n  if ((value === undefined || value === null) && (typeof props === 'string' || Array.isArray(props))) {\n    value = props;\n  } else {\n    Object.assign(node, props);\n  }\n  if (Array.isArray(value)) {\n    // @ts-expect-error: create a parent.\n    node.children = value;\n  } else if (value !== undefined && value !== null) {\n    // @ts-expect-error: create a literal.\n    node.value = String(value);\n  }\n  return node;\n};","map":null,"metadata":{},"sourceType":"module"}